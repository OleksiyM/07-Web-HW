# ---------------------------------
# AWS CodeWhisper ai code generated
# ---------------------------------
from django.core.cache import cache

def factorial(n):\
    if n in cache:
        return cache[n]
    else:
        cache[n] = n * factorial(n - 1)
        return cache[n]

# fibonacci function with cache
def fibonacci(n):
    if n in cache:
        return cache[n]
    else:
        cache[n] = fibonacci(n - 1) + fibonacci(n - 2)
        return cache[n]


# -----------------------------    
# Google Bard AI code generated
# -----------------------------
class Emailer:
    def __init__(self, email_address):
        self.email_address = email_address

    def generate_email_body(self, name, message):
        body = f"Hi {name},\n\n{message}\n\nSincerely,\nThe Team"
        return body

    def send_email(self, body):
        # Email sending logic using an external library
        return True

emailer = Emailer("example@domain.com")
body = emailer.generate_email_body("John", "This is a test email")
emailer.send_email(body)

class EmailBodyGenerator:
    def generate_email_body(self, name, message):
        body = f"Hi {name},\n\n{message}\n\nSincerely,\nThe Team"
        return body

class EmailSender:
    def __init__(self, email_service):
        self.email_service = email_service

    def send_email(self, email_address, body):
        self.email_service.send_email(email_address, body)

email_body_generator = EmailBodyGenerator()
body = email_body_generator.generate_email_body("John", "This is a test email")
email_sender = EmailSender(EmailService())  # Replace with actual service
email_sender.send_email("example@domain.com", body)


class Shape:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        raise NotImplementedError

class Square(Shape):
    def calculate_area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return 3.14 * self.radius**2

square = Square(5, 5)
circle = Circle(10)

# New shapes require extending existing classes which might not be ideal

print(square.calculate_area())
print(circle.calculate_area())


from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def calculate_area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return 3.14 * self.radius**2

# Extend functionality without modifying existing classes
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def calculate_area(self):
        return 0.5 * self.base * self.height


square = Rectangle(5, 5)
circle = Circle(10)
triangle = Triangle(5, 10)

print(square.calculate_area())
print(circle.calculate_area())
print(triangle.calculate_area())


# --------------------------------------
# AI code generated by chat.deepseek.com
# --------------------------------------

import argparse
import requests
from bs4 import BeautifulSoup
import json

# Base URL of the website
base_url = 'http://quotes.toscrape.com'

def scrape_quotes(page):
    # Construct the full URL for the current page
    url = f'{base_url}/page/{page}/'

    # Send a GET request to the URL
    response = requests.get(url)

    # If the response was successful, no Exception will be raised
    response.raise_for_status()

    # Get the content of the response
    soup = BeautifulSoup(response.text, 'html.parser')

    # Find all quotes on the page
    quotes = soup.select('.quote')

    # If there are no quotes on the page, we've reached the end
    if not quotes:
        return []

    # Initialize lists to store quotes and authors
    quotes_list = []
    authors_list = []

    # For each quote, print the text and the author
    for quote in quotes:
        text = quote.select_one('.text').get_text()
        author = quote.select_one('.author').get_text()
        print(f'Quote: {text}\nAuthor: {author}\n')

        # Get the author's URL
        author_url = quote.select_one('.author + a')['href']

        # Construct the full URL for the author's page
        author_url = f'{base_url}{author_url}'

        # Send a GET request to the author's page
        author_response = requests.get(author_url)

        # If the response was successful, no Exception will be raised
        author_response.raise_for_status()

        # Get the content of the response
        author_soup = BeautifulSoup(author_response.text, 'html.parser')

        # Get the author's birthdate
        birthdate = author_soup.select_one('.author-born-date').get_text()

        # Get the author's location
        location = author_soup.select_one('.author-born-location').get_text()

        print(f'Birthdate: {birthdate}\nLocation: {location}\n')

        # Append the quote and author to their respective lists
        quotes_list.append(text)
        authors_list.append({
            'name': author,
            'birthdate': birthdate,
            'location': location
        })

    return quotes_list, authors_list

def main():
    # Create an ArgumentParser object
    parser = argparse.ArgumentParser(description='Scrape quotes and authors from a website.')

    # Add an optional argument for the page number
    parser.add_argument('-p', '--page', type=int, default=1, help='The page number to scrape.')

    # Parse the command line arguments
    args = parser.parse_args()

    # Scrape the quotes and authors from the specified page
    quotes, authors = scrape_quotes(args.page)

    # Save the quotes and authors to JSON files
    with open('quotes.json', 'w') as f:
        json.dump(quotes, f)

    with open('authors.json', 'w') as f:
        json.dump(authors, f)

if __name__ == '__main__':
    main()

